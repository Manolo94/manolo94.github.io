<html>
    <head>
        <style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;
			}
		</style>
        
        <script src="js/jquery_v1.9.0.js"></script>
        <script src="libs/three.js"></script>
        <script src="libs/threex.keyboardstate.js"></script>
        <script src="libs/threex.text.js"></script>
    </head>
    <body>
        <div id="container">
            <div id="blocker">
                <div id="instructions">
                </div>
            </div>
        </div>
        
        <!-- ---------------- Custom Shader Code ------------------------ -->
        <script id="vertexShader" type="x-shader/x-vertex">
        uniform sampler2D noiseTexture;
        uniform float noiseScale;

        uniform sampler2D bumpTexture;
        uniform float bumpSpeed;
        uniform float bumpScale;

        uniform float time;

        varying vec2 vUv;

        void main() 
        { 
            vUv = uv;

            vec2 uvTimeShift = vUv + vec2( 1.1, 1.9 ) * time * bumpSpeed;
            vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
            vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.g );
            // below, using uvTimeShift seems to result in more of a "rippling" effect
            //   while uvNoiseTimeShift seems to result in more of a "shivering" effect
            vec4 bumpData = texture2D( bumpTexture, uvTimeShift );

            // move the position along the normal
            //  but displace the vertices at the poles by the same amount
            float displacement = ( vUv.y > 0.999 || vUv.y < 0.001 ) ? 
                bumpScale * (0.3 + 0.02 * sin(time)) :  
                bumpScale * bumpData.r;
            vec3 newPosition = position + normal * displacement;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
        }
        </script>

        <!-- fragment shader a.k.a. pixel shader -->
        <script id="fragmentShader" type="x-shader/x-vertex"> 
        uniform sampler2D baseTexture;
        uniform float baseSpeed;
        uniform float repeatS;
        uniform float repeatT;

        uniform sampler2D noiseTexture;
        uniform float noiseScale;

        uniform sampler2D blendTexture;
        uniform float blendSpeed;
        uniform float blendOffset;

        uniform float time;
        uniform float alpha;

        varying vec2 vUv;

        void main() 
        {
            vec2 uvTimeShift = vUv + vec2( -0.7, 1.5 ) * time * baseSpeed;	
            vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
            vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );
            vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift * vec2(repeatS, repeatT) );

            vec2 uvTimeShift2 = vUv + vec2( 1.3, -1.7 ) * time * blendSpeed;	
            vec4 noiseGeneratorTimeShift2 = texture2D( noiseTexture, uvTimeShift2 );
            vec2 uvNoiseTimeShift2 = vUv + noiseScale * vec2( noiseGeneratorTimeShift2.g, noiseGeneratorTimeShift2.b );
            vec4 blendColor = texture2D( blendTexture, uvNoiseTimeShift2 * vec2(repeatS, repeatT) ) - blendOffset * vec4(1.0, 1.0, 1.0, 1.0);

            vec4 theColor = baseColor + blendColor;
            theColor.a = alpha;
            gl_FragColor = theColor;
        }  
        </script>
        <!-- ----------------------------------------------------------- -->
        
        <script>
            var clock = new THREE.Clock();
            
            var camera, scene, renderer;
            var pointer, raycaster, mouse = {};
            
            var windowWidth, windowHeight;
            
            var debugSphere;
            
            var sPosition;
            
            function createLavaSphere()
            {
                // base image texture for mesh
                var lavaTexture = new THREE.ImageUtils.loadTexture( 'images/lava.jpg');
                lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping; 
                // multiplier for distortion speed 		
                var baseSpeed = 0.02;
                // number of times to repeat texture in each direction
                var repeatS = repeatT = 4.0;

                // texture used to generate "randomness", distort all other textures
                var noiseTexture = new THREE.ImageUtils.loadTexture( 'images/cloud.png' );
                noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping; 
                // magnitude of noise effect
                var noiseScale = 0.5;

                // texture to additively blend with base image texture
                var blendTexture = new THREE.ImageUtils.loadTexture( 'images/lava.jpg' );
                blendTexture.wrapS = blendTexture.wrapT = THREE.RepeatWrapping; 
                // multiplier for distortion speed 
                var blendSpeed = 0.01;
                // adjust lightness/darkness of blended texture
                var blendOffset = 0.25;

                // texture to determine normal displacement
                var bumpTexture = noiseTexture;
                bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping; 
                // multiplier for distortion speed 		
                var bumpSpeed   = 0.05;
                // magnitude of normal displacement
                var bumpScale   = 2.0;

                // use "this." to create global object
                this.customUniforms = {
                    baseTexture: 	{ type: "t", value: lavaTexture },
                    baseSpeed:		{ type: "f", value: baseSpeed },
                    repeatS:		{ type: "f", value: repeatS },
                    repeatT:		{ type: "f", value: repeatT },
                    noiseTexture:	{ type: "t", value: noiseTexture },
                    noiseScale:		{ type: "f", value: noiseScale },
                    blendTexture:	{ type: "t", value: blendTexture },
                    blendSpeed: 	{ type: "f", value: blendSpeed },
                    blendOffset: 	{ type: "f", value: blendOffset },
                    bumpTexture:	{ type: "t", value: bumpTexture },
                    bumpSpeed: 		{ type: "f", value: bumpSpeed },
                    bumpScale: 		{ type: "f", value: bumpScale },
                    alpha: 			{ type: "f", value: 1.0 },
                    time: 			{ type: "f", value: 1.0 }
                };

                // create custom material from the shader code above
                //   that is within specially labeled script tags
                var customMaterial = new THREE.ShaderMaterial( 
                {
                    uniforms: customUniforms,
                    vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
                    fragmentShader: document.getElementById( 'fragmentShader' ).textContent
                }   );

                var ballGeometry = new THREE.SphereGeometry( 2, 64, 64 );
                var ball = new THREE.Mesh(	ballGeometry, customMaterial );
                scene.add( ball );
                console.log('Lave sphere done');
            }
            
            function init()
            {
                container = document.getElementById( 'container' );
                
                keyboard = new THREEx.KeyboardState();
                
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 10000 );
                camera.position.y = 10;
                
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2( 0x000000, 0.06 );
                
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setClearColor( 0x000000, 1.0 );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );
                renderer.shadowMap.enabled = true;
                
                // Objects
                // Models
                var g = new THREE.BoxGeometry(10,10,10, 20, 20, 20);
                var radius = 5;
                for (var i in g.vertices) {
                    var vertex = g.vertices[i];
                    vertex.normalize().multiplyScalar(radius);
                }
                
                g.dynamic = true;
                g.normalsNeedUpdate = true;
                
                debugSphere = new THREE.Mesh( g, new THREE.MeshPhongMaterial({color: 'brown', fog: false}));
                debugSphere.castShadow = true;
                
                //otherSphere = new THREE.Mesh( new THREE.SphereGeometry(1,3,3), new THREE.MeshBasicMaterial({color: 'red', fog: false}));
                
                sPosition = debugSphere.position.clone();
                sPosition.negate();
                
                
                for( var i = 0; i < debugSphere.geometry.vertices.length; i++ )
                    {                        
                        var v = debugSphere.geometry.vertices[i].clone();
                        v.add( sPosition );
                        v.normalize();
                        var r = Math.random()*0.1 - 0.05;
                        
                        debugSphere.geometry.vertices[i].x -= v.x*r;
                        debugSphere.geometry.vertices[i].y -= v.y*r;
                        debugSphere.geometry.vertices[i].z -= v.z*r;
                    }
                    
                debugSphere.geometry.verticesNeedUpdate = true;
                debugSphere.geometry.normalsNeedUpdate = true;
                
                /* Compute normals */
                debugSphere.geometry.computeFaceNormals();
                debugSphere.geometry.computeVertexNormals();
                
                // Light
                var point1 = new THREE.PointLight(0xffffff, 1, 100);
                point1.position.x = -10;
                point1.position.y = 10;
                point1.position.z = 0;
                
                var point2 = new THREE.PointLight(0xff0000, 4.0, 10);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point2.position.z = 3;
                
                var point3 = new THREE.PointLight(0xff0000, 4.0, 10);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point3.position.z = -3;
                
                var point4 = new THREE.PointLight(0xff0000, 4.0, 10);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point4.position.y = 3;
                
                var point5 = new THREE.PointLight(0xff0000, 4.0, 10);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point5.position.y = -3;
                
                var light = new THREE.AmbientLight( 0x101010 ); // soft white light
                
                // Add all objects
                scene.add(debugSphere);
                //scene.add(otherSphere);
                scene.add(point1);
                scene.add(point2);
                scene.add(point3);
                scene.add(point4);
                scene.add(point5);
                scene.add( light );
                
                // Create lava ball
                createLavaSphere();
                
                camera.lookAt(debugSphere.position);
                
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                
                raycaster = new THREE.Raycaster();
                
                render();
            }
            
            function onDocumentMouseMove( event ) 
            {
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}
            
            function onDocumentMouseDown( event ) 
            {                
                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                // update the picking ray with the camera and mouse position	
                raycaster.setFromCamera( mouse, camera );	

                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects( [debugSphere] );
                
                if( intersects.length > 0 )
                    {                        
                        extrudeFaceInsideSphere( intersects[0].face.a, debugSphere.geometry, 0.5, debugSphere.position );
                        extrudeFaceInsideSphere( intersects[0].face.b, debugSphere.geometry, 0.5, debugSphere.position );
                        extrudeFaceInsideSphere( intersects[0].face.c, debugSphere.geometry, 0.5, debugSphere.position );
                    }
                
//                    for( var i = 0; i < debugSphere.geometry.vertices.length; i++ )
//                    {                        
//                        //var v = debugSphere.geometry.vertices[i].clone();
//                        //v.add( sPosition );
//                        //v.normalize();
//                        var r = Math.random()*0.5 - 0.25;
//                        
//                        debugSphere.geometry.vertices[i].x -= debugSphere.geometry.vertices[i].normalv.x*r;
//                        debugSphere.geometry.vertices[i].y -= v.y*r;
//                        debugSphere.geometry.vertices[i].z -= v.z*r;
//                    }
                    
                debugSphere.geometry.verticesNeedUpdate = true;
                debugSphere.geometry.normalsNeedUpdate = true;
                
                /* Compute normals */
                debugSphere.geometry.computeFaceNormals();
                debugSphere.geometry.computeVertexNormals();
			}
            
            function updateSize()
            {
                if( windowWidth != window.innerWidth || windowHeight != window.innerHeight )
                {
                    windowWidth = window.innerWidth;
                    windowHeight = window.innerHeight;
                    
                    renderer.setSize( windowWidth, windowHeight );
                }
            }
            
            /*
             * Remember to call geometry.computeFaceNormals();
             *                  geometry.computeVertexNormals();
             */
            function extrudeFaceInsideSphere( faceIndex, sphereGeometry, extrudeAmount, sphereCenter )
            {
                var v = sphereGeometry.vertices[faceIndex].clone();
                v.add( sphereCenter.clone().negate() );
                v.normalize();
                                
                sphereGeometry.vertices[faceIndex].x -= v.x*extrudeAmount;
                sphereGeometry.vertices[faceIndex].y -= v.y*extrudeAmount;
                sphereGeometry.vertices[faceIndex].z -= v.z*extrudeAmount;
            }
            
            var i = 0;
            var cameraAngle = 0;
            var delta = 0;
            function render()
            {
                updateSize();
                
                // Update the fireball
                customUniforms.time.value += delta;
                
                //if( i >= debugSphere.geometry.vertices.length )
                    //i = 0;
                //debugSphere.geometry.vertices[i].z += 1;
                //debugSphere.geometry.verticesNeedUpdate = true;
                
                //i++;
                
                cameraAngle += delta*Math.PI / 40;
                if( cameraAngle >= 2*Math.PI )
                    cameraAngle = 0;
                
                camera.position.x = Math.sin( cameraAngle )*10;
                camera.position.z = Math.cos( cameraAngle )*10;
                
                camera.lookAt(debugSphere.position);
                
                
                
                delta = clock.getDelta();
                
                requestAnimationFrame( render );
                renderer.render( scene, camera );
            }
            
            window.onload = init;
        </script>
    </body>
</html>