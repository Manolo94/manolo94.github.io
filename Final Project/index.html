<html>
    <head>
        <style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;
			}
		</style>
        
        <script src="js/jquery_v1.9.0.js"></script>
        <script src="js/controls.js"></script>
        <script src="libs/three.js"></script>
        <script src="libs/threex.keyboardstate.js"></script>
        <script src="libs/threex.text.js"></script>
        <script src="js/GPUParticleSystem.js" charset="utf-8"></script>
        <script src="js/asteroid.js"></script>    
        <script src="js/shield.js"></script> 
    </head>
    <body>
        <div id="container">
            <div id="blocker">
                <div id="instructions">
                </div>
            </div>
        </div>
        
        <!-- ---------------- Custom Shader Code ------------------------ -->
        <script id="planetCoreVertexShader" type="x-shader/x-vertex">
        uniform sampler2D noiseTexture;
        uniform float noiseScale;

        uniform sampler2D bumpTexture;
        uniform float bumpSpeed;
        uniform float bumpScale;

        uniform float time;

        varying vec2 vUv;

        void main() 
        { 
            vUv = uv;

            vec2 uvTimeShift = vUv + vec2( 1.1, 1.9 ) * time * bumpSpeed;
            vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
            vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.g );
            // below, using uvTimeShift seems to result in more of a "rippling" effect
            //   while uvNoiseTimeShift seems to result in more of a "shivering" effect
            vec4 bumpData = texture2D( bumpTexture, uvTimeShift );

            // move the position along the normal
            //  but displace the vertices at the poles by the same amount
            float displacement = ( vUv.y > 0.999 || vUv.y < 0.001 ) ? 
                bumpScale * (0.3 + 0.02 * sin(time)) :  
                bumpScale * bumpData.r;
            vec3 newPosition = position + normal * displacement;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
        }
        </script>

        <!-- fragment shader a.k.a. pixel shader -->
        <script id="planetCoreFragmentShader" type="x-shader/x-vertex"> 
        uniform sampler2D baseTexture;
        uniform float baseSpeed;
        uniform float repeatS;
        uniform float repeatT;

        uniform sampler2D noiseTexture;
        uniform float noiseScale;

        uniform sampler2D blendTexture;
        uniform float blendSpeed;
        uniform float blendOffset;

        uniform float time;
        uniform float alpha;

        varying vec2 vUv;

        void main() 
        {
            vec2 uvTimeShift = vUv + vec2( -0.7, 1.5 ) * time * baseSpeed;	
            vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
            vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );
            vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift * vec2(repeatS, repeatT) );

            vec2 uvTimeShift2 = vUv + vec2( 1.3, -1.7 ) * time * blendSpeed;	
            vec4 noiseGeneratorTimeShift2 = texture2D( noiseTexture, uvTimeShift2 );
            vec2 uvNoiseTimeShift2 = vUv + noiseScale * vec2( noiseGeneratorTimeShift2.g, noiseGeneratorTimeShift2.b );
            vec4 blendColor = texture2D( blendTexture, uvNoiseTimeShift2 * vec2(repeatS, repeatT) ) - blendOffset * vec4(1.0, 1.0, 1.0, 1.0);

            vec4 theColor = baseColor + blendColor;
            theColor.a = alpha;
            gl_FragColor = theColor;
        }  
        </script>
        
        <script type="x-shader/x-vertex" id="asteroidVertexShader">

                //
                // GLSL textureless classic 3D noise "cnoise",
                // with an RSL-style periodic variant "pnoise".
                // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
                // Version: 2011-10-11
                //
                // Many thanks to Ian McEwan of Ashima Arts for the
                // ideas for permutation and gradient selection.
                //
                // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
                // Distributed under the MIT license. See LICENSE file.
                // https://github.com/ashima/webgl-noise
                //

                vec3 mod289(vec3 x)
                {
                  return x - floor(x * (1.0 / 289.0)) * 289.0;
                }

                vec4 mod289(vec4 x)
                {
                  return x - floor(x * (1.0 / 289.0)) * 289.0;
                }

                vec4 permute(vec4 x)
                {
                  return mod289(((x*34.0)+1.0)*x);
                }

                vec4 taylorInvSqrt(vec4 r)
                {
                  return 1.79284291400159 - 0.85373472095314 * r;
                }

                vec3 fade(vec3 t) {
                  return t*t*t*(t*(t*6.0-15.0)+10.0);
                }

                // Classic Perlin noise
                float cnoise(vec3 P)
                {
                  vec3 Pi0 = floor(P); // Integer part for indexing
                  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
                  Pi0 = mod289(Pi0);
                  Pi1 = mod289(Pi1);
                  vec3 Pf0 = fract(P); // Fractional part for interpolation
                  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                  vec4 iy = vec4(Pi0.yy, Pi1.yy);
                  vec4 iz0 = Pi0.zzzz;
                  vec4 iz1 = Pi1.zzzz;

                  vec4 ixy = permute(permute(ix) + iy);
                  vec4 ixy0 = permute(ixy + iz0);
                  vec4 ixy1 = permute(ixy + iz1);

                  vec4 gx0 = ixy0 * (1.0 / 7.0);
                  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                  gx0 = fract(gx0);
                  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                  vec4 sz0 = step(gz0, vec4(0.0));
                  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                  vec4 gx1 = ixy1 * (1.0 / 7.0);
                  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                  gx1 = fract(gx1);
                  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                  vec4 sz1 = step(gz1, vec4(0.0));
                  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                  g000 *= norm0.x;
                  g010 *= norm0.y;
                  g100 *= norm0.z;
                  g110 *= norm0.w;
                  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                  g001 *= norm1.x;
                  g011 *= norm1.y;
                  g101 *= norm1.z;
                  g111 *= norm1.w;

                  float n000 = dot(g000, Pf0);
                  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                  float n111 = dot(g111, Pf1);

                  vec3 fade_xyz = fade(Pf0);
                  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
                  return 2.2 * n_xyz;
                }

                // Classic Perlin noise, periodic variant
                float pnoise(vec3 P, vec3 rep)
                {
                  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
                  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
                  Pi0 = mod289(Pi0);
                  Pi1 = mod289(Pi1);
                  vec3 Pf0 = fract(P); // Fractional part for interpolation
                  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                  vec4 iy = vec4(Pi0.yy, Pi1.yy);
                  vec4 iz0 = Pi0.zzzz;
                  vec4 iz1 = Pi1.zzzz;

                  vec4 ixy = permute(permute(ix) + iy);
                  vec4 ixy0 = permute(ixy + iz0);
                  vec4 ixy1 = permute(ixy + iz1);

                  vec4 gx0 = ixy0 * (1.0 / 7.0);
                  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                  gx0 = fract(gx0);
                  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                  vec4 sz0 = step(gz0, vec4(0.0));
                  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                  vec4 gx1 = ixy1 * (1.0 / 7.0);
                  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                  gx1 = fract(gx1);
                  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                  vec4 sz1 = step(gz1, vec4(0.0));
                  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                  g000 *= norm0.x;
                  g010 *= norm0.y;
                  g100 *= norm0.z;
                  g110 *= norm0.w;
                  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                  g001 *= norm1.x;
                  g011 *= norm1.y;
                  g101 *= norm1.z;
                  g111 *= norm1.w;

                  float n000 = dot(g000, Pf0);
                  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                  float n111 = dot(g111, Pf1);

                  vec3 fade_xyz = fade(Pf0);
                  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
                  return 2.2 * n_xyz;
                }

                varying vec2 vUv;
                varying float noise;
                uniform float time;

                //these values affect the form of the asteroid
                float turbulence( vec3 p ) {
                  float w = 100.0;
                  float t = -.5;
                  for (float f = 1.0 ; f <= 10.0 ; f++ ){
                    float power = pow( 2.7, f );
                    t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
                  }
                  return t;
                }

                void main() {

                  vUv = uv;

                  noise = 10.0 *  -.10 * turbulence( .5 * normal + time );
                  float b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );
                  float displacement = - 10. * noise + b;

                  vec3 newPosition = position + normal * displacement;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );

                }

          </script>

          <script type="x-shader/x-vertex" id="asteroidFragmentShader">
                varying vec2 vUv;
                varying float noise;
                uniform sampler2D tExplosion;

                float random( vec3 scale, float seed ){
                  return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;
                }

                void main() {

                  float r = .01 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );
                  vec2 tPos = vec2( 0, 1.0 - 1.3 * noise + r );
                  vec4 color = texture2D( tExplosion, tPos );
                  gl_FragColor = vec4( color.rgb, 1.0 );

                }
          </script>
        <!-- ----------------------------------------------------------- -->
        
        <script>
            var clock = new THREE.Clock();
            
            var camera, cameraController, scene, renderer;
            cameraHorizontalAngle = 0, cameraVerticalAngle = 0;
            var pointer, raycaster, mouse = {};
            var asteroidType = ['ice', 'fire', 'nova'];
            var asteroids = [];
            var shields = [];
            
            var windowWidth, windowHeight;
            
            var planetSphere, defenseSphere;
            
            var PLANET_RADIUS = 30, DEFENSE_RADIUS = 35;
            
            var sPosition;
            
            function createLavaSphere()
            {
                // base image texture for mesh
                var lavaTexture = new THREE.ImageUtils.loadTexture( 'images/lava.jpg');
                lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping; 
                // multiplier for distortion speed 		
                var baseSpeed = 0.02;
                // number of times to repeat texture in each direction
                var repeatS = repeatT = 4.0;

                // texture used to generate "randomness", distort all other textures
                var noiseTexture = new THREE.ImageUtils.loadTexture( 'images/cloud.png' );
                noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping; 
                // magnitude of noise effect
                var noiseScale = 0.5;

                // texture to additively blend with base image texture
                var blendTexture = new THREE.ImageUtils.loadTexture( 'images/lava.jpg' );
                blendTexture.wrapS = blendTexture.wrapT = THREE.RepeatWrapping; 
                // multiplier for distortion speed 
                var blendSpeed = 0.01;
                // adjust lightness/darkness of blended texture
                var blendOffset = 0.25;

                // texture to determine normal displacement
                var bumpTexture = noiseTexture;
                bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping; 
                // multiplier for distortion speed 		
                var bumpSpeed   = 0.05;
                // magnitude of normal displacement
                var bumpScale   = 2.0;

                // use "this." to create global object
                this.customUniforms = {
                    baseTexture: 	{ type: "t", value: lavaTexture },
                    baseSpeed:		{ type: "f", value: baseSpeed },
                    repeatS:		{ type: "f", value: repeatS },
                    repeatT:		{ type: "f", value: repeatT },
                    noiseTexture:	{ type: "t", value: noiseTexture },
                    noiseScale:		{ type: "f", value: noiseScale },
                    blendTexture:	{ type: "t", value: blendTexture },
                    blendSpeed: 	{ type: "f", value: blendSpeed },
                    blendOffset: 	{ type: "f", value: blendOffset },
                    bumpTexture:	{ type: "t", value: bumpTexture },
                    bumpSpeed: 		{ type: "f", value: bumpSpeed },
                    bumpScale: 		{ type: "f", value: bumpScale },
                    alpha: 			{ type: "f", value: 1.0 },
                    time: 			{ type: "f", value: 1.0 }
                };

                // create custom material from the shader code above
                //   that is within specially labeled script tags
                var customMaterial = new THREE.ShaderMaterial( 
                {
                    uniforms: customUniforms,
                    vertexShader:   document.getElementById( 'planetCoreVertexShader'   ).textContent,
                    fragmentShader: document.getElementById( 'planetCoreFragmentShader' ).textContent
                }   );

                var ballGeometry = new THREE.SphereGeometry( 15, 64, 64 );
                var ball = new THREE.Mesh(	ballGeometry, customMaterial );
                scene.add( ball );
                console.log('Lave sphere done');
            }
            
            function init()
            {
                tick = 0; spawnRate = 15000;
                
                container = document.getElementById( 'container' );
                
                keyboard = new THREEx.KeyboardState();
                
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 10000 );
                camera.position.y = 10;
                
                // Generate the camera controller
                cameraController = new Controls.PlanetCameraRotationController( camera );
                
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2( 0x000000, 0.06 );
                
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setClearColor( 0x000000, 1.0 );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );
                renderer.shadowMap.enabled = true;
                
                CreatePlanetSphere();
                CreateDefenseSphere();
                
                // Light
                var point1 = new THREE.PointLight(0xffffff, 1, 1000);
                point1.position.x = -100;
                point1.position.y = 100;
                point1.position.z = 0;
                
                var point2 = new THREE.PointLight(0xff0000, 4.0, PLANET_RADIUS*2);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point2.position.z = PLANET_RADIUS/2;
                
                var point3 = new THREE.PointLight(0xff0000, 4.0, PLANET_RADIUS*2);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point3.position.z = -PLANET_RADIUS/2;
                
                var point4 = new THREE.PointLight(0xff0000, 4.0, PLANET_RADIUS*2);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point4.position.y = PLANET_RADIUS/2;
                
                var point5 = new THREE.PointLight(0xff0000, 4.0, PLANET_RADIUS*2);
                //point2.position.x = 10;
                //point2.position.y = -10;
                point5.position.y = -PLANET_RADIUS/2;
                
                var light = new THREE.AmbientLight( 0x101010 ); // soft white light
                
                // Add all objects
                scene.add(planetSphere);
                scene.add(defenseSphere);
                //scene.add(otherSphere);
                scene.add(point1);
                scene.add(point2);
                scene.add(point3);
                scene.add(point4);
                scene.add(point5);
                scene.add( light );
                
                // Create lava ball
                createLavaSphere();
                
                // Create asteroids
                //new Asteroid(size, color, horizontalSpeed, verticalSpeed)        
                for( var i = 0; i < 3; i++)
                {
                    //25 asteroids, random position around planet, random color, size 4
                    var size = Math.floor(Math.random() * 4) + 2;
                    var color = asteroidType[Math.floor(Math.random() * 3) + 0];
                    var asteroid = new Asteroid( size, color, new THREE.Vector3());
                    
                    var alpha = Math.random()*Math.PI*2;
                    var beta = Math.random()*Math.PI*2;
                    var sphereRadius = 200;
                    
                    var circleRadius = Math.cos(beta)*sphereRadius;
                    
                    asteroid.positionX( Math.cos(alpha)*circleRadius );
                    asteroid.positionY( Math.sin(alpha)*circleRadius );
                    asteroid.positionZ( Math.sin(beta)*sphereRadius );
                    
                    var velTowardPlanet = asteroid.asteroid.position.clone().negate().normalize().multiplyScalar(0.1);
                    console.log(velTowardPlanet);
                  asteroid.option.velocity = velTowardPlanet;
                    
                  //  asteroid.normalize();
                    //asteroid.multiplyScalar(200);
                    
                    asteroids.push(asteroid);
                }
                
                //point2.position.x = 10;
                //point2.position.y = -10;
                point3.position.z = -PLANET_RADIUS/2;
                
                camera.lookAt(planetSphere.position);
                
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup'  , onDocumentMouseUp,   false );
                
                raycaster = new THREE.Raycaster();
                
                render();
            }
            
            function onDocumentMouseMove( event ) 
            {
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}
            
            function onDocumentMouseDown( event ) 
            {
                cameraController.Start();
                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                // update the picking ray with the camera and mouse position	
                raycaster.setFromCamera( mouse, camera );	

                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects( [planetSphere] );
                
                if( intersects.length > 0 )
                    {                        
                        extrudeFaceInsideSphere( intersects[0].face.a, planetSphere.geometry, 2, planetSphere.position );
                        extrudeFaceInsideSphere( intersects[0].face.b, planetSphere.geometry, 2, planetSphere.position );
                        extrudeFaceInsideSphere( intersects[0].face.c, planetSphere.geometry, 2, planetSphere.position );
                    }
                
//                    for( var i = 0; i < planetSphere.geometry.vertices.length; i++ )
//                    {                        
//                        //var v = planetSphere.geometry.vertices[i].clone();
//                        //v.add( sPosition );
//                        //v.normalize();
//                        var r = Math.random()*0.5 - 0.25;
//                        
//                        planetSphere.geometry.vertices[i].x -= planetSphere.geometry.vertices[i].normalv.x*r;
//                        planetSphere.geometry.vertices[i].y -= v.y*r;
//                        planetSphere.geometry.vertices[i].z -= v.z*r;
//                    }
                    
                planetSphere.geometry.verticesNeedUpdate = true;
                planetSphere.geometry.normalsNeedUpdate = true;
                
                /* Compute normals */
                planetSphere.geometry.computeFaceNormals();
                planetSphere.geometry.computeVertexNormals();
			}
            
            function onDocumentMouseUp( event )
            {
                cameraController.Stop();
            }
            

            function CreatePlanetSphere()
            {
                // Objects
                // Models
                var g = new THREE.BoxGeometry(200,200,200, 20, 20, 20);
                
                for (var i in g.vertices) {
                    var vertex = g.vertices[i];
                    vertex.normalize().multiplyScalar(PLANET_RADIUS);
                }
                
                g.dynamic = true;
                g.normalsNeedUpdate = true;
                
                planetSphere = new THREE.Mesh( g, new THREE.MeshPhongMaterial({color: 'brown', fog: false}));
                planetSphere.castShadow = true;
                
                //otherSphere = new THREE.Mesh( new THREE.SphereGeometry(1,3,3), new THREE.MeshBasicMaterial({color: 'red', fog: false}));
                
                sPosition = planetSphere.position.clone();
                sPosition.negate();
                
                
                for( var i = 0; i < planetSphere.geometry.vertices.length; i++ )
                    {                        
                        var v = planetSphere.geometry.vertices[i].clone();
                        v.add( sPosition );
                        v.normalize();
                        var r = Math.random()*0.1 - 0.05;
                        
                        planetSphere.geometry.vertices[i].x -= v.x*r;
                        planetSphere.geometry.vertices[i].y -= v.y*r;
                        planetSphere.geometry.vertices[i].z -= v.z*r;
                    }
                    
                planetSphere.geometry.verticesNeedUpdate = true;
                planetSphere.geometry.normalsNeedUpdate = true;
                
                /* Compute normals */
                planetSphere.geometry.computeFaceNormals();
                planetSphere.geometry.computeVertexNormals();
            }
            
            function CreateDefenseSphere()
            {
                // Objects
                // Models
                

                
                var materials = [ new THREE.MeshPhongMaterial({color: 'blue', fog: false, transparent:true, opacity:0.1}),
                                  new THREE.MeshPhongMaterial({color: 'blue', fog: false, side: THREE.DoubleSide}),
                                  new THREE.MeshPhongMaterial({color: 'red', fog: false}),
                                  new THREE.MeshPhongMaterial({color: 'gray', fog: false}),
                              new THREE.MeshPhongMaterial({color: 'gray', fog: false}),
                              new THREE.MeshPhongMaterial({color: 'gray', fog: false})];
                
                var g = new THREE.BoxGeometry(200,200,200, 20, 20, 20);
                

                
                g.dynamic = true;
                g.normalsNeedUpdate = true;
                
                for (var i in g.vertices) {
                    var vertex = g.vertices[i];
                    vertex.normalize().multiplyScalar(DEFENSE_RADIUS);
                }
                
                //number of shields per axis
                var nsa = 8;
                
                g.verticesNeedUpdate = true;
                g.normalsNeedUpdate = true;
                
                /* Compute normals */
                g.computeFaceNormals();
                g.computeVertexNormals();
                
                for( var f = 0; f < g.faces.length; f++ )
                {
//                    g.faces[i].materialIndex = 0;
//                    
//                    if( i > g.faces.length / 2 )
//                        g.faces[i].materialIndex = 1;
                    
                    var vertex = g.vertices[ g.faces[f].a ].clone();
                    
                    var beta = Math.asin(vertex.z/DEFENSE_RADIUS);
                    
                    var d = vertex.x/(Math.cos(beta) * DEFENSE_RADIUS);
                    if( d > 1 )
                        d = 1;
                    if( d < -1 )
                        d = -1;
                    
                    var alpha = Math.acos( d );
                    
                    console.log("test= " + (alpha) + " " +vertex.x/(Math.cos(beta) * DEFENSE_RADIUS) );
                    
                    var i = Math.floor((alpha+Math.PI/2)/(2 * Math.PI) * nsa);
                    var j = Math.floor((beta+Math.PI/2)/(2 * Math.PI) * nsa);
                    
                    console.log( "alpha =" + alpha + " beta =" + beta + " i =" + i + " j =" + j);
                                    
                    if(shields[ i + j * nsa] === undefined)
                    {
                        shields[ i + j * nsa] = new Shield();
                    }
                    
                    shields[ i + j * nsa].AddFaceIndex( f );
                    
                }
                
                for( var s = 0; s < shields.length; s++ )
                {
                    var shield = shields[s];
                    
                    if( shield === undefined )
                        continue;
                    
                    for( var f = 0; f <  shield.faceIndex.length; f++ )
                        {
                            g.faces[ shield.faceIndex[f] ].materialIndex = s%4;
                        }
                }
                
                defenseSphere = new THREE.Mesh( g, new THREE.MeshFaceMaterial() );            

                
                defenseSphere.material.materials = materials;
                
                
                defenseSphere.castShadow = true;
                
                //otherSphere = new THREE.Mesh( new THREE.SphereGeometry(1,3,3), new THREE.MeshBasicMaterial({color: 'red', fog: false}));
                
                sPosition = defenseSphere.position.clone();
                sPosition.negate();
                
                defenseSphere.geometry.verticesNeedUpdate = true;
                defenseSphere.geometry.normalsNeedUpdate = true;
                
                /* Compute normals */
                defenseSphere.geometry.computeFaceNormals();
                defenseSphere.geometry.computeVertexNormals();
            }
            
            function collideAsteroid( asteroid )
            {
                // update the picking ray with the camera and mouse position	
                raycaster.set( asteroid.asteroid.position.clone(), asteroid.option.velocity.clone().normalize() );
                
                if( asteroid.asteroid.position.length() > 40 || asteroid.asteroid.position.length() < 20 )
                    return;

                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects( [planetSphere] );
                
                if( intersects.length > 0 )
                    {                        
                        extrudeFaceInsideSphere( intersects[0].face.a, planetSphere.geometry, 2, planetSphere.position );
                        extrudeFaceInsideSphere( intersects[0].face.b, planetSphere.geometry, 2, planetSphere.position );
                        extrudeFaceInsideSphere( intersects[0].face.c, planetSphere.geometry, 2, planetSphere.position );
                    }
                
//                    for( var i = 0; i < planetSphere.geometry.vertices.length; i++ )
//                    {                        
//                        //var v = planetSphere.geometry.vertices[i].clone();
//                        //v.add( sPosition );
//                        //v.normalize();
//                        var r = Math.random()*0.5 - 0.25;
//                        
//                        planetSphere.geometry.vertices[i].x -= planetSphere.geometry.vertices[i].normalv.x*r;
//                        planetSphere.geometry.vertices[i].y -= v.y*r;
//                        planetSphere.geometry.vertices[i].z -= v.z*r;
//                    }
                    
                planetSphere.geometry.verticesNeedUpdate = true;
                planetSphere.geometry.normalsNeedUpdate = true;
                
                /* Compute normals */
                planetSphere.geometry.computeFaceNormals();
                planetSphere.geometry.computeVertexNormals();
            }
            
            function updateSize()
            {
                if( windowWidth != window.innerWidth || windowHeight != window.innerHeight )
                {
                    windowWidth = window.innerWidth;
                    windowHeight = window.innerHeight;
                    
                    renderer.setSize( windowWidth, windowHeight );
                }
            }
            
            /*
             * Remember to call geometry.computeFaceNormals();
             *                  geometry.computeVertexNormals();
             */
            function extrudeFaceInsideSphere( faceIndex, sphereGeometry, extrudeAmount, sphereCenter )
            {
                var v = sphereGeometry.vertices[faceIndex].clone();
                v.add( sphereCenter.clone().negate() );
                v.normalize();
                                
                sphereGeometry.vertices[faceIndex].x -= v.x*extrudeAmount;
                sphereGeometry.vertices[faceIndex].y -= v.y*extrudeAmount;
                sphereGeometry.vertices[faceIndex].z -= v.z*extrudeAmount;
            }
            
            var i = 0;
            var delta = 0;
            function render()
            {
                updateSize();
                cameraController.UpdateCameraPosition();
                
                // Update the fireball
                customUniforms.time.value += delta;
                
                //if( i >= planetSphere.geometry.vertices.length )
                    //i = 0;
                //planetSphere.geometry.vertices[i].z += 1;
                //planetSphere.geometry.verticesNeedUpdate = true;
                
                //i++;
                
                //------------------ASTEROID ANIMATION-----------------
                      tick += delta;

                      if (tick < 0) tick = 0;

                      if (delta > 0) {

                          //move the asteroids                         
                          for(var i = 0; i < asteroids.length; i++)
                          {
                              asteroids[i].rotationXYZ(0.02); 
                          }
                          
//                          asteroid1.positionX(-Math.sin(tick * asteroid1.spawnOptions.horizontalSpeed) * 60);
//                          asteroid1.rotationXYZ(0.02);                          

//                          asteroid2.positionX(Math.sin(tick * asteroid2.spawnOptions.horizontalSpeed) * 50);
//                          asteroid2.rotationXYZ(0.02);
//
//                          asteroid3.positionX(Math.sin(tick * asteroid3.spawnOptions.horizontalSpeed) * 40);
//                          asteroid3.rotationXYZ(0.02);
                          
                          

                        for (var x = 0; x < spawnRate * delta; x++) {
                            //spawn particles
                            for(var i = 0; i < asteroids.length; i++)
                            {
                                asteroids[i].partSystem.spawnParticle(asteroids[i].option);
                            }
                        }
                      }
                      //update the particle system
                      for(var i = 0; i < asteroids.length; i++)
                      {
                          asteroids[i].partSystem.update(tick);
                          asteroids[i].update();
                          collideAsteroid(asteroids[i]);
                          //asteroids[i].positionX(Math.sin(tick * 1) * 40);
                      }
                
                //--------------------------------------------------------
                
                cameraAngle += delta*Math.PI / 40;
                cameraAngle += delta*Math.PI / 10;
                if( cameraAngle >= 2*Math.PI )
                    cameraAngle = 0;

                camera.position.x = Math.sin( cameraAngle ) *75;
                camera.position.y = Math.cos( cameraAngle ) *75;
                camera.position.z = */
                
                camera.lookAt(planetSphere.position);
                
                delta = clock.getDelta();
                
                requestAnimationFrame( render );
                renderer.render( scene, camera );
            }
            
            window.onload = init;
        </script>
    </body>
</html>